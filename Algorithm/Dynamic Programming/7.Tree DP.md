# 7. 樹 DP (Tree DP)

### 7.1 337. 打家劫舍 III

**題目分析**

* 給定一棵二叉樹，每個節點有金額，不能同時搶相鄰節點。
* 求最大搶劫金額。
* 樹 DP，節點狀態依賴子節點。

**狀態設計**

* `dp[node] = [不搶, 搶]`
* dp[node][0] = 不搶 node 的最大金額
* dp[node][1] = 搶 node 的最大金額

**狀態轉移方程**

* `dp[node][0] = max(dp[left]) + max(dp[right])`
* `dp[node][1] = node.val + dp[left][0] + dp[right][0]`

**程式碼**

```python
class Solution:
    def rob(self, root: TreeNode) -> int:
        def dfs(node):
            if not node:
                return (0,0)
            left = dfs(node.left)
            right = dfs(node.right)
            rob_node = node.val + left[0] + right[0]
            not_rob_node = max(left) + max(right)
            return (not_rob_node, rob_node)
        return max(dfs(root))
```

**解釋**

* 每個節點選擇搶或不搶，子節點依賴父節點狀態
* 使用 tuple 記錄兩種狀態，避免重複計算
* 最終取根節點最大值

---

### 7.2 124. 二叉樹中的最大路徑和

**題目分析**

* 求二叉樹任意路徑的最大和，路徑不必經過根。
* 樹 DP，考慮節點與左右子樹最大貢獻

**狀態設計**

* `dfs(node)` = 返回以 node 為起點的最大貢獻（只能選擇一側）
* 全局變數 max_sum 記錄全局最大

**程式碼**

```python
class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        max_sum = float('-inf')
        def dfs(node):
            nonlocal max_sum
            if not node:
                return 0
            left = max(dfs(node.left), 0)
            right = max(dfs(node.right), 0)
            max_sum = max(max_sum, node.val + left + right)
            return node.val + max(left, right)
        dfs(root)
        return max_sum
```

**解釋**

* 左右子樹貢獻為正才計入
* max_sum 記錄節點加左右子樹最大路徑和
* dfs 返回以節點為起點的最大貢獻

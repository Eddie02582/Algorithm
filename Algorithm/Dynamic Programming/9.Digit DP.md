# 9. Digit DP (數位 DP)

### 9.1 基本概念

**題目分析**

* Digit DP 適合處理「數字範圍內的數字特性統計」問題，例如：
  - 某範圍內有多少個數字滿足某些數字條件
  - 某範圍內數字和為某值
* 核心是**逐位考慮數字，記錄狀態**。

**狀態設計**

* pos = 當前處理到哪一位（從高位到低位）
* tight = 是否已達上界限制（如果前面選的位數已等於 n 的前幾位）
* state = 額外狀態，如數字和、個位數計數、是否含某數字等

**狀態轉移方程**

* 遍歷當前位可選數字：
```
for d in range(0, upper_bound):
    newState = update(state, d)
    ans += dfs(pos+1, newState, tight & (d==upper_bound))
```

**初始化**

* 從最高位開始，tight = True，state = 初始值

---

### 9.2 902. Numbers At Most N Given Digit Set

**題目分析**

* 給定數字集合 D 和整數 N，計算 <= N 的數字有多少個，只使用 D 的數字。
* 適合 Digit DP，逐位生成。

**狀態設計**

* pos = 當前位
* tight = 是否已達 N 的限制
* state = 無需額外狀態，只計數

**程式碼**

```python
class Solution:
    def atMostNGivenDigitSet(self, D, N: int) -> int:
        s = str(N)
        memo = {}
        n = len(s)

        def dfs(pos, tight):
            if pos == n:
                return 1
            if (pos, tight) in memo:
                return memo[(pos, tight)]
            ans = 0
            upper = int(s[pos]) if tight else 9
            for d in D:
                if int(d) > upper:
                    continue
                ans += dfs(pos+1, tight and int(d)==upper)
            memo[(pos, tight)] = ans
            return ans

        return dfs(0, True)
```

**解釋**

* tight 控制是否受 N 限制
* 每位可選數字小於上界
* memo 避免重複計算

---

### 9.3 2376. Count Special Integers

**題目分析**

* 計算 <= n 的整數中，各位數字不重複的數量。
* Digit DP + 狀態壓縮（用 bitmask 記錄已使用數字）

**狀態設計**

* pos = 當前位
* tight = 是否受 n 限制
* mask = 已使用數字的 bitmask

**程式碼**

```python
class Solution:
    def countSpecialNumbers(self, n: int) -> int:
        s = str(n)
        memo = {}

        def dfs(pos, mask, tight):
            if pos == len(s):
                return 1
            if (pos, mask, tight) in memo:
                return memo[(pos, mask, tight)]
            ans = 0
            upper = int(s[pos]) if tight else 9
            for d in range(0, upper+1):
                if mask & (1<<d):
                    continue
                if mask==0 and d==0:  # leading zero
                    ans += dfs(pos+1, mask, tight and d==upper)
                else:
                    ans += dfs(pos+1, mask | (1<<d), tight and d==upper)
            memo[(pos, mask, tight)] = ans
            return ans

        return dfs(0, 0, True)
```

**解釋**

* mask 記錄已使用數字
* 避免重複數字
* tight 控制上界
* DFS + memo 避免重複計算

---

### 9.4 心法整理

* Digit DP 適合數字範圍 + 位數限制問題
* 核心三個維度：pos、tight、狀態（state/bitmask）
* 注意 leading zero 特殊處理
* memo 化是必須，否則 TLE
* 額外狀態可用 bitmask 或累積變數表示

---

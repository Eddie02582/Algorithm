# 8. 狀態壓縮 DP (State Compression DP)

### 8.1 基本概念

**題目分析**

* 當問題需要紀錄哪些元素已使用、子集選擇或排列狀態時，傳統多維 DP 維度會爆炸。
* 使用 bitmask（二進位遮罩）表示狀態，例如 10110 表示第 2、3、5 個元素已使用。

**適用場景**

* 旅行商問題 (TSP)
* 任務分配 / 配對問題
* 子集 DP / 排列最佳化
* BFS + visited mask

---

### 8.2 698. Partition to K Equal Sum Subsets

**題目分析**

* 判斷陣列能否分成 k 個子集合，每個子集合和相等。
* 轉成 subset sum + bitmask 選擇問題。

**狀態設計**

* mask 表示哪些元素已選
* curSum 當前子集合累積和

**狀態轉移方程**

* 若選第 i 個數：
```
newMask = mask | (1<<i)
newSum = (curSum + nums[i]) % target
dp[newMask] = True / False
```

**程式碼**

```python
class Solution:
    def canPartitionKSubsets(self, nums, k):
        total = sum(nums)
        if total % k != 0:
            return False
        target = total // k
        nums.sort(reverse=True)
        n = len(nums)
        memo = {}

        def dfs(mask, curSum):
            if mask == (1 << n) - 1:
                return True
            if (mask, curSum) in memo:
                return memo[(mask, curSum)]
            for i in range(n):
                if not (mask & (1<<i)) and curSum + nums[i] <= target:
                    newMask = mask | (1<<i)
                    newSum = (curSum + nums[i]) % target
                    if dfs(newMask, newSum):
                        memo[(mask, curSum)] = True
                        return True
            memo[(mask, curSum)] = False
            return False

        return dfs(0, 0)
```

**解釋**

* mask 控制元素是否使用
* DFS + 記憶化避免重複計算
* bitmask 讓狀態以單一整數表示

---


### 8.3 526. Beautiful Arrangement

**題目分析**

* 對 1~n 排列，使每個位置 i 的數字 nums[i] 可被 i 整除或能整除 i。
* 排列 + 選擇狀態問題 → bitmask DP。

**狀態設計**

* mask 表示已使用的數字
* pos 當前排列位置

**狀態轉移方程**

* 對每個可用數字 i：
```
if (mask & (1<<i)) == 0 and (i % pos == 0 or pos % i == 0):
    newMask = mask | (1<<i)
    ans += dfs(pos+1, newMask)
```

**程式碼**

```python
class Solution:
    def countArrangement(self, n: int) -> int:
        memo = {}

        def dfs(pos, mask):
            if pos > n:
                return 1
            if (pos, mask) in memo:
                return memo[(pos, mask)]
            ans = 0
            for i in range(1, n+1):
                if not (mask & (1<<i)) and (i % pos == 0 or pos % i == 0):
                    ans += dfs(pos+1, mask | (1<<i))
            memo[(pos, mask)] = ans
            return ans

        return dfs(1, 0)
```

**解釋**

* mask 控制已使用數字
* pos 控制排列位置
* DFS + 記憶化避免重複計算

---

### 8.4 1255. Maximum Score Words Formed by Letters

**題目分析**

* 有一堆單詞、字母與字母分數，挑選單詞組合，使分數最大，單詞不能重複，字母有限制。
* 本質是 **子集 + 資源限制** → bitmask DP。

**狀態設計**

* mask 表示已選單詞集合
* dp[mask] = 最大分數

**狀態轉移方程**

* 對每個未選單詞：
```
newMask = mask | (1<<i)
dp[newMask] = max(dp[newMask], dp[mask] + score_of_word_i)
```

**程式碼概念**

```python
# 難度較高，示意概念
# 遍歷所有 subset mask，更新 dp[newMask]
```

**解釋**

* 每個 mask 表示一個單詞子集
* 對每個可用單詞更新分數
* bitmask 避免多維 DP

---

### 8.5 心法整理

* 若狀態屬於「集合、子集、排列」，優先考慮 bitmask DP
* 狀態空間 = 2^n × 其他變數 → 使用 memo 避免 TLE
* mask 維度太大 → 可搭配 BFS、DFS + pruning
* 子集迴圈順序很重要：通常從小到大或從大到小視題目限制

---

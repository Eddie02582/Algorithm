## 3. 0/1 背包 (0/1 Knapsack)

### 3.1 416. 分割等和子集

**題目分析**  
- 給定一個正整數陣列，判斷是否能分成兩個子集使得和相等。  
- 本質上是 0/1 背包問題：能否從陣列中選出一部分元素，使和為總和的一半。

**狀態設計**  
- `dp[i][j]` = 前 i 個元素能否湊成和 j  

**狀態轉移方程**  
- `dp[i][j] = dp[i-1][j] or dp[i-1][j-nums[i-1]]` (若 j >= nums[i-1])  

**初始化**  
- `dp[0][0] = True`  
- `dp[0][j>0] = False`  

**程式碼**
```python
class Solution:
    def canPartition(self, nums: List[int]) -> bool:
        total = sum(nums)
        if total % 2 != 0:
            return False
        target = total // 2
        n = len(nums)
        dp = [[False]*(target+1) for _ in range(n+1)]
        dp[0][0] = True
        
        for i in range(1, n+1):
            for j in range(target+1):
                dp[i][j] = dp[i-1][j]
                if j >= nums[i-1]:
                    dp[i][j] = dp[i][j] or dp[i-1][j-nums[i-1]]
        return dp[n][target]
```

**解釋**  
- 每個元素有兩種選擇：選或不選  
- dp[i][j] 表示前 i 個元素是否能湊成和 j  
- 最終查看 dp[n][target] 即可

---

### 3.2 494. 目標和

**題目分析**  
- 給定整數陣列 nums 和目標 target，給每個數字加上 '+' 或 '-'，求有多少種方法得到 target。  
- 可轉化為 0/1 背包問題，將目標拆成兩個子集和。

**狀態設計**  
- `dp[i][j]` = 前 i 個數字湊成和 j 的方法數  

**狀態轉移方程**  
- `dp[i][j] = dp[i-1][j-nums[i-1]] + dp[i-1][j+nums[i-1]]`  

**初始化**  
- `dp[0][0] = 1`  

**程式碼**
```python
class Solution:
    def findTargetSumWays(self, nums: List[int], target: int) -> int:
        total = sum(nums)
        if abs(target) > total:
            return 0
        offset = total
        dp = [[0]*(2*total+1) for _ in range(len(nums)+1)]
        dp[0][offset] = 1
        
        for i in range(1, len(nums)+1):
            for j in range(2*total+1):
                if dp[i-1][j]:
                    dp[i][j + nums[i-1]] += dp[i-1][j]
                    dp[i][j - nums[i-1]] += dp[i-1][j]
        return dp[len(nums)][target+offset]
```

**解釋**  
- 利用偏移量 offset 將負數索引轉成正索引  
- 每個數字選 '+' 或 '-' → 兩種更新方法數  
- dp[len(nums)][target+offset] 即最終答案

---

### 3.3 474. 一和零

**題目分析**  
- 給定字符串陣列 strs，每個元素由 '0' 和 '1' 組成，限制最多選 m 個 '0' 和 n 個 '1'，求最多能選多少個字符串。  
- 典型 0/1 背包，二維容量。

**狀態設計**  
- `dp[i][j]` = 使用 i 個 '0' 和 j 個 '1' 能選的最大字符串數  

**狀態轉移方程**  
- `dp[i][j] = max(dp[i][j], dp[i-count0][j-count1] + 1)` (若 i >= count0, j >= count1)  

**程式碼**
```python
from collections import Counter

class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp =[ [0]*(n+1) for _ in range(m+1)]      
        for s in strs:
            freq = Counter(s)
            count_zero = freq['0']
            count_one  = freq['1']            
            for i in range(m,count_zero - 1,-1):
                for j in range(n,count_one-1,-1):
                    dp[i][j] = max(dp[i][j], dp[i - count_zero][j - count_one] + 1)    
        return dp[m][n]
```

**解釋**  
- 典型二維 0/1 背包  
- 每個字符串只能選一次  
- 遍歷容量從大到小，避免重複計算  
- dp[m][n] 為最大選擇數量

# 5. 多維背包 (Multi-dimensional Knapsack)

### 5.1 474. 一和零 (擴展)

**題目分析**

* 給定字符串陣列 strs，每個元素由 '0' 和 '1' 組成，限制最多選 m 個 '0' 和 n 個 '1'，求最多能選多少個字符串。
* 本質是二維背包，每個字符串消耗兩種資源：0 和 1。

**狀態設計**

* `dp[i][j]` = 使用 i 個 '0' 和 j 個 '1' 可選的最大字符串數

**狀態轉移方程**

* `dp[i][j] = max(dp[i][j], dp[i-count0][j-count1]+1)`

**初始化**

* `dp[0][0] = 0`

**程式碼**

```python
from collections import Counter

class Solution:
    def findMaxForm(self, strs: List[str], m: int, n: int) -> int:
        dp = [[0]*(n+1) for _ in range(m+1)]
        for s in strs:
            cnt = Counter(s)
            zeros = cnt['0']
            ones = cnt['1']
            for i in range(m, zeros-1, -1):
                for j in range(n, ones-1, -1):
                    dp[i][j] = max(dp[i][j], dp[i-zeros][j-ones]+1)
        return dp[m][n]
```

**解釋**

* 二維背包，每個維度表示資源限制
* 遍歷容量從大到小避免重複選擇
* dp[m][n] 為最大選擇數量

---

### 5.2 1235. 形成目標字符串的最小成本

**題目分析**

* 有一堆字符串，每個字符串使用成本不同，要組合成目標字符串，求最小成本。
* 每個字符的位置限制 → 多維背包（每個字符一維資源）

**狀態設計**

* `dp[pos][c1][c2]...` = 到達 pos，消耗各字符資源後的最小成本

**狀態轉移方程**

* 根據選擇不同字符串更新每個字符資源消耗，取最小成本

**程式碼概念**

```python
# 難度較高，示意概念
# dp[pos][...] = min(dp[pos-1][...] + cost_of_current_choice)
```

**解釋**

* 多維背包可處理多種資源限制
* 每個維度表示不同類型資源
* 更新時考慮所有資源消耗組合

---

### 5.3 實戰心法

* 多維背包常見於限制多資源的問題
* 內層循環需逆序，防止重複使用
* 如果維度過多，可考慮狀態壓縮或 DFS + 記憶化

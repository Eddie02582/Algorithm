# 6. 區間 DP (Interval DP)

### 6.1 312. 戰役區間

**題目分析**

* 有一個數列表示氣球，每個氣球有數字，射破氣球 i 可獲得 nums[left]*nums[i]*nums[right] 分數。
* 問最終能獲得的最大分數。
* 本質是區間 DP，決定最後射哪個氣球。

**狀態設計**

* `dp[i][j]` = 射破區間 [i,j] 的最大分數

**狀態轉移方程**

* `dp[i][j] = max(dp[i][k-1] + nums[i-1]*nums[k]*nums[j+1] + dp[k+1][j])`
* k ∈ [i,j]，最後射破的氣球是 k

**初始化**

* `dp[i][i] = nums[i-1]*nums[i]*nums[i+1]`

**程式碼**

```python
class Solution:
    def maxCoins(self, nums: List[int]) -> int:
        nums = [1]+nums+[1]
        n = len(nums)
        dp = [[0]*n for _ in range(n)]
        for length in range(1, n-1):
            for left in range(1, n-length):
                right = left+length-1
                for k in range(left, right+1):
                    dp[left][right] = max(dp[left][right], dp[left][k-1]+nums[left-1]*nums[k]*nums[right+1]+dp[k+1][right])
        return dp[1][n-2]
```

**解釋**

* 將邊界補 1 方便計算
* dp[i][j] 依賴於左右子區間的最大分數
* 最終 dp[1][n-2] 即最大分數

---

### 6.2 221. 最大正方形

**題目分析**

* 給定二維矩陣，由 '0' 和 '1' 組成，求最大全 1 正方形面積。
* 可視為 2D 區間 DP。

**狀態設計**

* `dp[i][j]` = 以 (i,j) 為右下角的最大正方形邊長

**狀態轉移方程**

* `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1` (matrix[i][j]=='1')

**初始化**

* 第一行和第一列 dp[i][0] = matrix[i][0], dp[0][j] = matrix[0][j]

**程式碼**

```python
class Solution:
    def maximalSquare(self, matrix: List[List[str]]) -> int:
        if not matrix: return 0
        m, n = len(matrix), len(matrix[0])
        dp = [[0]*n for _ in range(m)]
        res = 0
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == '1':
                    if i==0 or j==0:
                        dp[i][j] = 1
                    else:
                        dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
                    res = max(res, dp[i][j])
        return res*res
```

**解釋**

* dp[i][j] 取決於左、上、左上三個方向最小邊長
* 最終 res^2 即最大正方形面積

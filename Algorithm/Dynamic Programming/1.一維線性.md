# 動態規劃

## 章節目錄

1. 一維線性 DP
2. 二維子序列 DP
3. 0/1 背包
4. 完全背包
5. 多維背包
6. 區間 DP
7. 樹 DP
8. 狀態壓縮 DP
9. Digit DP
10. 機率 DP / 預期值 DP

---

## 1. 一維線性 DP

### 70. 爬樓梯

**題目分析**

* 每次可以走 1 或 2 步，問到第 n 階有多少種方法。

**狀態設計**

* dp[i] = 到達第 i 階的方法數

**狀態轉移方程**

* dp[i] = dp[i-1] + dp[i-2]

**初始化**

* dp[0]=1, dp[1]=1

**程式碼**

```python
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0]*(n+1)
        dp[0] = 1
        dp[1] = 1
        for i in range(2, n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]
```

**解釋**

* dp[2] = dp[1]+dp[0] = 2
* dp[3] = dp[2]+dp[1] = 3
* 線性 DP 模板

### 198. 打家劫舍

**題目分析**

* 一排房子，每個房子有金額，不能偷相鄰房子。

**狀態設計**

* dp[i] = 前 i 間房子能取得的最大金額

**狀態轉移方程**

* dp[i] = max(dp[i-1], dp[i-2]+nums[i])

**初始化**

* dp[0] = nums[0]
* dp[1] = max(nums[0], nums[1])

**程式碼**

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums: return 0
        if len(nums) == 1: return nums[0]
        dp = [0]*len(nums)
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, len(nums)):
            dp[i] = max(dp[i-1], dp[i-2]+nums[i])
        return dp[-1]
```

優化空間

* 滾動變量寫法（prev / curr）
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        prev, curr = 0, 0
        for num in nums:
            prev, curr = curr, max(curr, prev + num)
        return curr
```
---
**狀態設計**

* dp_rob[i] 表示搶第 i 間房子時的最大值
* dp_no_rob[i] 表示不搶第 i 間房子時的最大值

**狀態轉移方程**

* dp_rob[i] = dp_no_rob[i-1] + nums[i]
* dp_no_rob[i] = max(dp_rob[i-1], dp_no_rob[i-1])

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        if not nums: 
            return 0
        n = len(nums)
        # dp_rob[i] 表示搶第 i 間房子時的最大值
        # dp_no_rob[i] 表示不搶第 i 間房子時的最大值
        dp_rob = [0] * n
        dp_no_rob = [0] * n

        # 初始化
        dp_rob[0] = nums[0]
        dp_no_rob[0] = 0

        for i in range(1, n):
            # 搶當前房子 → 前一間不能搶
            dp_rob[i] = dp_no_rob[i-1] + nums[i]
            # 不搶當前房子 → 前一間搶或不搶都可以，取最大
            dp_no_rob[i] = max(dp_rob[i-1], dp_no_rob[i-1])

        # 最後一間房子搶或不搶，取最大值
        return max(dp_rob[-1], dp_no_rob[-1])
```

優化空間（滾動變量 prev/curr）
```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        rob, no_rob = 0, 0
        for num in nums:
            rob, no_rob = no_rob + num, max(rob, no_rob)
        return max(rob, no_rob)
```


**解釋**
* 每間房子可選偷或不偷 → 選最大值
*DP array → 狀態明確，方便回溯誰被偷
*雙狀態 / rob-no_rob → 空間 O(1)，rob 表示搶當前房子，no_rob 表示不搶，邏輯對應 DP array
*滾動變量 prev/curr → 進一步壓縮空間，只保留前前一個與當前最大值與當前最大值

### 121. 買賣股票 I

**題目分析**

* 每天可持有或賣出股票，求最大利潤。

**狀態設計**

* min_price = 遍歷過程中最小價格
* max_profit = 目前最大利潤

**程式碼**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = float('inf')
        max_profit = 0
        for price in prices:
            min_price = min(min_price, price)
            max_profit = max(max_profit, price - min_price)
        return max_profit
```

**解釋**

* 每天更新最小價格，計算利潤，保留最大值

### 213. 打家劫舍 II

**題目分析**

* 房子排列成環，不能偷相鄰房子。

**狀態設計**

* 分別考慮偷第一間或不偷第一間，轉化為線性 DP

**程式碼**

```python
class Solution:
    def rob(self, nums: List[int]) -> int:
        def rob_line(houses):
            prev, curr = 0, 0
            for num in houses:
                prev, curr = curr, max(curr, prev+num)
            return curr
        if not nums: return 0
        if len(nums) == 1: return nums[0]
        return max(rob_line(nums[:-1]), rob_line(nums[1:]))
```

**解釋**

* 將環拆成兩條線性子問題 → 選最大值

### 122. 買賣股票 II

**題目分析**

* 可以多次交易，求最大利潤。

**程式碼**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        for i in range(1, len(prices)):
            if prices[i] > prices[i-1]:
                profit += prices[i]-prices[i-1]
        return profit
```

**解釋**

* 累加每次上漲的差值 → 最大利潤

### 309. 最佳買賣股票含冷卻期

**題目分析**

* 每次賣出後隔一天不能買入。

**狀態設計**

* not_hold = 不持有且可買入
* hold = 持有股票
* cooldown = 不持有且在冷卻期

**狀態轉移方程**

* new_not_hold = max(not_hold, cooldown)
* new_hold = max(hold, not_hold-price)
* new_cooldown = hold+price

**程式碼**

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        if not prices:
            return 0

        not_hold = 0  
        cooldown = 0 
        hold = -prices[0]  # 修正這裡
        
        for i in range(1, len(prices)):           
            new_cooldown = hold + prices[i]
            new_hold = max(hold, not_hold - prices[i])
            new_not_hold = max(not_hold, cooldown)
            
            hold = new_hold
            not_hold = new_not_hold
            cooldown = new_cooldown
        
        return max(not_hold, cooldown)

```

**解釋**

* 三種狀態每天更新 → 最終選最大值


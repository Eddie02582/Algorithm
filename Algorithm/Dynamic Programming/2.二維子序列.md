## 2. 二維子序列 DP

### 300. 最長遞增子序列

**題目分析**

* 求一個數列的最長遞增子序列長度。

**狀態設計**

* dp[i] = 以 nums[i] 結尾的 LIS 長度

**狀態轉移方程**

* dp[i] = max(dp[i], dp[j]+1) if nums[i] > nums[j]

**初始化**

* dp[i]=1

**程式碼**

```python
class Solution:
    def lengthOfLIS(self, nums: List[int]) -> int:
        n = len(nums)
        dp = [1]*n
        for i in range(1, n):
            for j in range(i):
                if nums[i] > nums[j]:
                    dp[i] = max(dp[i], dp[j]+1)
        return max(dp)
```

**解釋**

* 每個位置依賴前面比它小的數字 → 二維子序列 DP 模板

### 1143. 最長公共子序列

**題目分析**

* 求兩個字串的 LCS 長度。

**狀態設計**

* dp[i][j] = text1 前 i 字符和 text2 前 j 字符的 LCS 長度

**狀態轉移方程**

* if text1[i-1]==text2[j-1]: dp[i][j]=dp[i-1][j-1]+1
* else: dp[i][j]=max(dp[i-1][j], dp[i][j-1])

**初始化**

* dp[0][j]=0, dp[i][0]=0

**程式碼**

```python
class Solution:
    def longestCommonSubsequence(self, text1: str, text2: str) -> int:
        m, n = len(text1), len(text2)
        dp = [[0]*(n+1) for _ in range(m+1)]
        for i in range(1, m+1):
            for j in range(1, n+1):
                if text1[i-1]==text2[j-1]:
                    dp[i][j]=dp[i-1][j-1]+1
                else:
                    dp[i][j]=max(dp[i-1][j], dp[i][j-1])
        return dp[m][n]
```

**解釋**

* 每個位置依賴左、上、左上 → 二維子序列 DP 範例



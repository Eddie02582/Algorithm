# 4. 完全背包 (Complete Knapsack)

### 4.1 518. 雙倍硬幣

**題目分析**

* 給定整數陣列 coins，每個數字可以使用無限次，問有多少種組合使總和等於 amount。
* 典型完全背包問題，物品可重複。

**狀態設計**

* `dp[i]` = 湊成總和 i 的組合數

**狀態轉移方程**

* `dp[i] += dp[i-coin]` (對於每個 coin in coins, i >= coin)

**初始化**

* `dp[0] = 1`

**程式碼**

```python
class Solution:
    def change(self, amount: int, coins: List[int]) -> int:
        dp = [0]*(amount+1)
        dp[0] = 1
        for coin in coins:
            for i in range(coin, amount+1):
                dp[i] += dp[i-coin]
        return dp[amount]
```

**解釋**

* 完全背包中每個物品可以選無限次，所以內層循環從 coin 到 amount
* dp[i] 累加所有可能選法

---

### 4.2 322. 零錢兌換

**題目分析**

* 給定 coins 和 amount，求湊成 amount 的最少硬幣數。
* 每個 coin 可使用無限次 → 完全背包最小化問題。

**狀態設計**

* `dp[i]` = 湊成總和 i 所需最少硬幣數

**狀態轉移方程**

* `dp[i] = min(dp[i], dp[i-coin] + 1)`

**初始化**

* `dp[0] = 0`，其他 dp[i] = inf

**程式碼**

```python
class Solution:
    def coinChange(self, coins: List[int], amount: int) -> int:
        dp = [float('inf')] * (amount+1)
        dp[0] = 0
        for coin in coins:
            for i in range(coin, amount+1):
                dp[i] = min(dp[i], dp[i-coin]+1)
        return dp[amount] if dp[amount] != float('inf') else -1
```

**解釋**

* 內層循環從 coin 到 amount 保證每個 coin 可重複使用
* dp[i] 保持最小硬幣數
* 最終返回 dp[amount] 或 -1 若無解

---

### 4.3 377. 組合總和 IV

**題目分析**

* 給定整數陣列 nums 和 target，求所有加法組合數量，每個數字可無限使用。
* 完全背包組合數問題。

**狀態設計**

* `dp[i]` = 湊成總和 i 的組合數

**狀態轉移方程**

* `dp[i] += dp[i-num]`

**初始化**

* `dp[0] = 1`

**程式碼**

```python
class Solution:
    def combinationSum4(self, nums: List[int], target: int) -> int:
        dp = [0]*(target+1)
        dp[0] = 1
        for i in range(1, target+1):
            for num in nums:
                if i >= num:
                    dp[i] += dp[i-num]
        return dp[target]
```

**解釋**

* 先遍歷 i 再遍歷 nums → 計算組合數
* dp[i] 累加所有可行選項
* 最終 dp[target] 為結果

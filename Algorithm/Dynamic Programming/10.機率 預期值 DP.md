# 10. 機率 DP / 預期值 DP (Probability / Expected Value DP)

### 10.1 基本概念

**題目分析**

* 適合處理帶有隨機性或期望值計算的問題，例如：
  - 擲骰子期望值
  - 抽牌、隨機事件獲勝概率
  - 狀態轉移有概率分布

**狀態設計**

* dp[state] = 對應狀態的期望值或成功概率
* 狀態可以是剩餘步數、剩餘資源、當前位置等

**狀態轉移方程**

* 對每種可能事件 i：
```
dp[state] += probability[i] * dp[next_state[i]]
```

**初始化**

* 終止狀態直接給期望值或概率
* 其他狀態從終止狀態反向計算

---

### 10.2 478. Generate Random Point in a Circle

**題目分析**

* 在圓內均勻生成點 → 機率分布問題
* 可以用隨機數生成，但 DP 類似可處理離散概率累積

**程式碼**

```python
import random
import math

class Solution:

    def __init__(self, radius: float, x_center: float, y_center: float):
        self.radius = radius
        self.xc = x_center
        self.yc = y_center

    def randPoint(self):
        r = self.radius * math.sqrt(random.random())
        theta = random.random() * 2 * math.pi
        return [self.xc + r*math.cos(theta), self.yc + r*math.sin(theta)]
```

**解釋**

* sqrt(random()) 保持半徑均勻分布
* theta 均勻選擇角度
* 機率分布直接反映在坐標生成

---

### 10.3 837. New 21 Game

**題目分析**

* Alice 玩遊戲，每次抽取 1~maxPts，目標不超過 n，求贏的概率。
* DP + 機率累積 → 狀態是當前分數。

**狀態設計**

* dp[i] = 分數為 i 時贏的概率

**狀態轉移方程**

```
dp[i] = sum(dp[i - k] / maxPts) for k=1..maxPts if i-k >= 0
```

**程式碼**

```python
class Solution:
    def new21Game(self, n: int, k: int, maxPts: int) -> float:
        if k == 0 or n >= k + maxPts:
            return 1.0
        dp = [0.0] * (n+1)
        dp[0] = 1.0
        Wsum = 1.0
        for i in range(1, n+1):
            dp[i] = Wsum / maxPts
            if i < k:
                Wsum += dp[i]
            if i - maxPts >= 0:
                Wsum -= dp[i - maxPts]
        return sum(dp[k:])
```

**解釋**

* sliding window 技巧優化 O(n*maxPts) → O(n)
* dp[i] 機率累積自前 maxPts 個狀態
* 最後累加 dp[k..n] 為最終贏的概率

---

### 10.4 心法整理

* 機率 DP 核心：期望值 / 成功概率 = 各事件概率加權累計
* 絕大多數問題狀態可用一維或二維 DP 表示
* 注意累加概率時的邊界條件
* 遇到大範圍可考慮滑動窗口或前綴和優化
* 如果有隨機事件且可以分解 → 可以用 DP 求期望值或成功率

---
